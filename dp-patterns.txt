0/1 knapsack:

- dp[i][j] = most profit with j capacity, considering first i items
- dp[i][j] = max(dp[i][j], dp[i-1][j-w[i]] + p[i])

Can optimise to 1d dp
- for j loop, iterate reverse otherwise you could read dp[i][j] values instead of dp[i-1][j].
- Also so you don't reuse same item multiple times.

Unbounded knapsack:

- dp[i][j] = most profit with j capacity, considering first i items
- dp[i][j] = max(dp[i][j], dp[i][j-w[i]] + p[i])

0/1 : Read from previous row.
Unbounded: May reuse from current row.